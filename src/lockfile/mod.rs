use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;
use std::fs;
use std::path::Path;
use anyhow::{Context, Result};

#[cfg(test)]
mod test_lockfile;

/// Package state in lockfile
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct PackageState {
    pub fetch_hash: Option<String>,
    pub build_hash: Option<String>,
}

/// The lockfile tracks build hashes and symlink hashes
#[derive(Debug, Serialize, Deserialize, Default)]
pub struct SproutLock {
    pub modules: BTreeMap<String, PackageState>,
    pub symlinks: BTreeMap<String, String>, // symlink_path -> content_hash
}

impl SproutLock {
    /// Load lockfile from sprout.lock
    pub fn load(sprout_path: &str) -> Result<Self> {
        let lock_path = Path::new(sprout_path).join("sprout.lock");

        if !lock_path.exists() {
            return Ok(Self::default());
        }

        let content = fs::read_to_string(&lock_path)
            .with_context(|| format!("Failed to read lockfile: {}", lock_path.display()))?;

        let lock = toml::from_str(&content)
            .with_context(|| "Failed to parse lockfile")?;

        Ok(lock)
    }

    /// Save lockfile to sprout.lock
    pub fn save(&self, sprout_path: &str) -> Result<()> {
        let lock_path = Path::new(sprout_path).join("sprout.lock");

        let content = toml::to_string_pretty(self)
            .with_context(|| "Failed to serialize lockfile")?;

        // Add header comment
        let content = format!(
            "# Auto-generated by Sprout â€” do not edit\n\n{}",
            content
        );

        fs::write(&lock_path, content)
            .with_context(|| format!("Failed to write lockfile: {}", lock_path.display()))?;

        Ok(())
    }

    /// Get package state
    pub fn get_module_state(&self, module_id: &str) -> Option<&PackageState> {
        self.modules.get(module_id)
    }

    /// Set package state
    pub fn set_module_state(&mut self, module_id: String, state: PackageState) {
        self.modules.insert(module_id, state);
    }

}
